# 07/05

`클로저`

- 자신을 내포하는 함수의 컨텍스트에 접근할 수 있는 함수
- 함수가 특정 소코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의하는 것
- 함수를 선언할 때 만들어지는 유효범위가 사라진 후에도 호출할 수 있는 함수
- 이미 생명 주기상 끝난 외부 함수의 변수를 참조하는 함수
- 자유변수가 있는 함수와 자유변수를 알 수 있는 환경의 결합
- 로컬 변수를 참조하고 있는 함수 내의 함수
- 자신이 생성될 때의 스코프에서 알 수 있었던 변수들 중 언젠가 자신이 실행될 때 사용할 변수들만을 기억하여 유지시키는 함수

`외부 함수의 변수를 참조하는 내부함수_1`

```jsx
var outer = function () {
  var a = 1;
  var inner = function () {
    console.log(++a);
    // 출력 : 2
  };
  inner();
};
outer();
```

- inner() 내부에 a가 없음
- inner() 의 environmentRecord에서 찾지 못함
- inner() 의 outerenviconmentReference에 지정된 outer의 LexicalEnvironment 접근
- outer() 의 LexicalEnvironment에서 a를 찾음
- outer() 의 실행컨텍스트 종료시 LexicalEnvironment에 저장된 (a, inner)에 대한 참조 지움
- 각 주소에 저장돼 있던 값들은 자신을 참조하는 변수가 없게 됨
- 가비지 컬렉터의 수집 대상

```jsx
var outer = function () {
  var a = 1;
  var inner = function () {
    console.log(++a);
    // 출력 : 2
  };
  inner();
  // LexicalEnvironment
  //     environmentRecord : {}
  //     outerEnvironmentReference : {outer LexicalEnvironment}
  //     바로 위가 outer함수 이므로
};
outer();
// LexicalEnvironment
//     environmentRecord : {a:1, inner 함수}
//     outerEnvironmentReference : {outer 함수}
```

- inner() 의 outerenviconmentReference에 지정된 outer의 LexicalEnvironment 접근
- inner() 와 제일 가까운 outer()의 LexicalEnvironment에 접근 하여 a를 가져옴
- outer() 의 실행 컨텍스트가 종료되기 이전에 inner() 의 실행 컨텍스트 종료
- innter() 호출 불가

`외부 함수의 변수를 참조하는 내부함수_1`

```jsx
var outer = function () {
  var a = 1;
  var inner = function () {
    return ++a;
  };
  return inner;
  // return inner();
};

var outer2 = outer();
console.log(outer2()); // 2
console.log(outer2()); // 3

// console.log(outer2); // 2
// console.log(outer2); // 2
```

- 첫번째 console.log(outer2())에서 outer() 는 결과값으로 2를 출력
- outer() 는 이미 실행이 종료된 상태
- 그러나, 두번째 console.log(outer2())를 실행 할 때 inner() 의 outerEnvironmentReference가 outer()의 LexicalEnvironment를 참조
- 가비지 컬렉터의 동작 방식에 의해 연결이 끊기지 않음
- 외부 함수의 LexicalEnviconment가 가비지 컬렉팅되지 않음

> 가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면
>
> 그 값은 수집 대상에 포함시키지 않습니다

`클로저 재정의`

- 클로저란 외부함수 A에서 선언한 변수 a를 참조하는
- 내부함수 B를 외부로 전달할 경우
- 외부 함수 A의 실행 컨텍스트가 종료된 이후에도
- 변수 a가 사라지지 않는 현상

`return 없이도 클로저가 발생하는 예제`

```jsx
(function () {
  var a = 0;
  var intervalID = null;
  var inner = function () {
    if (++a >= 10) {
      clearInterval(intervalID);
    }
    console.log(a);
    console.log(intervalID);
  };
  intervalID = setInterval(inner, 1000);
})();

// 1
// 2
// 3
// ...
// 10
```

- 지역변수를 참조하는 inner함수를
- 외부에 전달 했기 때문에 클로저

`클로저의 메모리 관리`

```jsx
var outer = (function () {
  var a = 1;
  var inner = function () {
    return ++a;
  };
  return inner;
})();
console.log(outer());
console.log(outer());
outer = null;
// 메모리 헤제
```

- 필요성이 사라진 시점에 더는 메모리를 소모하지 않게 해주기 위해
- 참조 카운트를 0으로 만들면 가비지 컬렉터가 수거해 감
- 참조 카운터를 0으로 만들기 위해서는
- null, undefined를 할당 하면 됨

`클로저 활용 사례_ 콜백함수와 클로저`

```jsx
var fruits = ["apple", "banana", "peach"];
var $ul = document.createElement("ul");

fruits.forEach(function (fruit) {
  // (A)
  var $li = document.createElement("li");
  $li.innerHTML = fruit;
  $li.addEventListener("click", function () {
    //(B)
    alert("너의 선택은 : " + fruit);
    // 외부 변수 fruit 참조 <- 클로저
  });
  $ul.appendChild($li);
});

document.body.appendChild($ul);

// - apple  (클릭시, "너의 선택은 : apple" 출력)
// - banana (클릭시, "너의 선택은 : banana" 출력)
// - peach  (클릭시, "너의 선택은 : peach" 출력)
```

- A 함수 의 실행 종료 여부와 무관
- B 함수 (클릭 이벤트)에 의해
- B 함수 outerEnvironmentReference가
- A 함수 의 LexicalEnvironment를 참조
- B 함수가 참조할 예정인 변수 fruit에 대해서
- A 함수가 종료되어도 가비지 콜렉터 대상에서 제외되어 계속 참조 가능
