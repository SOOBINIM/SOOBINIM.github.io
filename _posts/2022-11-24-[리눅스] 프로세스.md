---
categories: etc
---

# 프로세스 구성요소의 이해

## 용어 정리

프로그램 : 어떤 작업을 위해 실행할 수 있는 파일 또는 프로그램.exe

프로세스 : 메모리에 적재되고 CPU 자원을 할당받아 프로그램이 실행되고 있는 상태

쓰레드 : 프로세스 내의 실행 흐름

PID : 커널에서 각 프로세스에 부여한 고유한 ID

PPID : 프로세스를 복제한 부모의 PID

Niceness : 프로세스 스케쥴리의 우선순위를 결정

## 프로세스

- 각각 독립된 메모리 영역을 할당 받는다.
  - Code : 프로그래머가 작성한 프로그램이 저장되는 영역
  - Data : 코드에 사용한 변수나 파일들의 각종 데이터들이 모여있음
  - Stack : 호출한 함수가 종료되면 되돌아올 메모리의 주소가 저장되는 영역
  - Heap : 동적으로 할당되는 데이터들을 위해 존재하는 공간
- 기본적으로 프로세스당 최소 1개의 스레드를 가지고 있다.
- 한 프로세스에서 다른 프로세스의 변수나 자료구조에 접근할 수 없음
  - 별도의 주소 공간에서 실행된다.
- 프로세스 간의 통신을 위해서는 IPC(Inter Process Communication)을 사용
  - 파이프, 파일, 소켓 등을 이용한 통신 방법

<aside>
💡 동시에 실행하는게 아니라 너무 빨라서 동시에 하는것 처럼 보임

</aside>

## 쓰레드

- 프로세스 내에서 각각 stack만 따로 할당 받음
  - Code, Data, Heap 영역은 공유
- 같은 프로세스 안에 있는 여러 스레드들은 같은 힙 공간을 공유
  - 메모리를 교환하고 있기 때문에 커널의 도움없이 메세지 주고 받을 수 있다. 성능적으로 큰 도움
- Lightweight process라고 불리며, 작업을 실행할 수 있는 가장 작은 단위
- 리눅스 입장에서는 프로세스와 스레드를 구분하지 않는다.
- 한 프로세스 내에서 병렬적인 작업 수행
- 쓰레드를 만들려면 레지스터와 스택만 만들어주면 됨

<aside>
💡 차이점 : 공유를 하고 안하고의 차이점

</aside>

## PID

- 프로세스가 생성되는 순서대로 배정
- 부호형 (signed) 16비트 정수 자료형를 사용하기 때문에 최댓값은 32,768이다.
- 32,768를 넘어가면 다시 1부터 시작

## 프로세스 계층

- init 프로세스 (=pid 1)는 최초 프로세스이다.
- init 프로세스는 부팅시 운영체제가 생성
- 프로세스는 다른 프로세스로부터 생성

## PPID

- 리눅스에서 새 프로그램을 시작하는 시스템 콜이 없음
- 자식 프로세스를 시스템 콜을 호출하여 생성한 프로세스
- 기존 프로세스를 복제 하고 프로그램을 교체하는 방식을 사용

```powershell
$./parent.sh &
$ ps -A -o pid,ppid,pgid,sid,command
```

### UID

생성된 프로세스가 속한 `사용자` 아이디

### GID

생성된 프로세스가 속한 `그룹` 아이디

### 트리구조

부모 프로세스가 자식 프로세스를 만드는 과정이 반복되면 트리구조가 형성 이를 구분하기 위해 pid를 사용한다.

- 이를 프로세스 트리라고 한다 줄여서 pstree

## Niceness

- NI(Nicevalue or Niceness)
- 프로세스 스케줄링의 우선순위를 결정
- 우선순위가 높다는 뜻은 CPU 사용시간이 많다는 것
- 값의 범위는 -20 ~+19 (작을 수록 불친절하고 우선순위가 높다는 뜻)
- CPU 성능, 스케줄러 , I/O요청등의 영향으로 우선순위를 조정하는 경우는 흔치 않음.
- NI 값으로 확인

```powershell
$ps ax -o pid,ni,cmd
```

## 정리

프로세스는 고유의 아이디인 PID를 갖고,

부모 프로세스와 자식 프로세스의 관계를 맺으며

실행 우선순위와 상태를 갖는다.

# 프로세스 라이프 사이클의 이해

## 신규 프로세스 생성

### fork

- 시스템 콜로 부모가 자신을 **복제**하여 자식 프로세스 생성
  - 시스템 콜 : 프로세스의 생성은 사용자 프로그램이 운영체제에 요청에 의해 실행 (즉, **프로세스를 만들어달라고 운영체제에 부탁**)
- 자식 프로세스는 0을 반환
- 부모 프로세스는 새로 생성된 자식의 PID을 반환 받는다.

### exec

- 자식 프로세스가 주소공간에 새로운 프로그램을 올림
  - 새 주소 공간을 만들고 새 프로그램을 로드
- **현재 실행하고 있는 프로그램을 다른 것으로 교체**
- **fork는 부모 프로세스의 주소 공간을 복사해서 새로운 프로세스에게 메모리를 할당 해주는데**
- **exec는 현재 프로그램의 메모리 영역에 exec의 인자로 전달된 프로그램의 메모리로 덮어씌어버리는 함수**
- 즉, 원래 부모 프로세스로부터 복제된 프로그램 코드는 새로운 코드로 덮어져 사라지게 됨
- 포크된 프로세스를 새로운 프로그램으로 로드하게 해준다
- **자식 프로세스가 종료될 때까지 부모 프로세스는 wait**

## 자식 프로세스 종료

### wait

- 부모 프로세스는 방해하지 않기 위해 wait() 시스템 콜을 호출하여 대기
- 작업을 마친 자식 프로세스가 exit()를 통해 시스템에게 알린다.
- 부모 프로세스가 자식프로세스를 wait()하는 상황에서 자식 프로세스를 종료하는 것이 바람직한 프로세스를 종료하는 구조이다.

### 좀비 프로세스

- 자식 프로세스가 exit() 시스템콜을 실행하면 모든 리소스들을 해제시키지만 부모 프로세스가 자식 프로세스의 상태를 알고 싶어할 상황을 대비하여 최소한의 정보는 커널에 저장하고 있게 됨.
- **자식 프로세스는 종료 되었는데 부모가 wait()를 호출 하지 않을 때**
- 혹시라도 부모 프로세스에게 필요한 정보나 시스템에 중요한 정보를 가지고 있을 수 있기 때문에 남겨둠

### 고아 프로세스 (Orphan Process)

- **부모 프로세스가 이미 죽었는데, 자식 프로세스가 살아있는 경우**
- 부모가 wait()를 호출하지 않은 채로 자식보다 먼저 종료
- 이 고아 프로세스는 init process의 자식으로 설정
- 즉, init process가 대신 부모 역할을 맡게 되어 wiat() 시스템 콜을 호출

### 프로세스 상태

**RUNNING**

- 프로세스가 실행 가능한 상태
- 현재 실행 중 또는 실행큐에 실행 대기 상태
- 스케줄링 로직에 의해 실행 됨

**INTERRUPTIBLE (웨이팅 상태)**

- 특정 조건을 기다리며 프로세스가 대기 또는 중단 상태
- 기다리다가 조건이 발생 또는 시그널 받으면 실행가능 상태로 이동

**UNINTERRUPTIBLE (웨이팅 상태)**

- INTERRUBTIBLE과 동일한 상태이지만 시그널을 받아도 깨어나지 않음
- 프로세스가 다른 방해를 받지 않고 반드시 대기해야 하는경우
- 세마포어를 잡고 중요한 동작을 하고 있는 경우
  - 세마포어란 여러개의 프로세스가 동시에 공유자원에 접근
  - 기찻길 깃발 표식에서 깃발을 세마포어라고 부름
  - 세마포어는 공유자원의 개수를 나타내는 변수 이다.
  - 1개의 서버에 5개의 프린터
    - 프린터 5대
    - 사용할 때마다 하나씩 감소
    - 사용할 프린터가 없을 때는 0
    - 다 쓰고 반환하면 세마포어가 1

**ZOMBIE**

- 프로세스가 중단된 상태
- 부모 프로세스가 wait 시스템 콜을 호출하지 않은 상태

## 프로세스 상태 모니터링

### ps

- 프로세스와 관련된 주요 지표들을 표시
  - PID, UID, 우선순위, 컨트롤 터미널, 프로세스별 메모리 크기, 소비한 CPU 시간, 현재 상태 (실행, 중지, 대기 등)
- ps aux : 실행중인 모든 프로세스에 대한 정보 표시
  - a : 모든 프로세스
  - u : 사용자 지향적 출력
  - x : 터미널이 없는 프로세스도 표시
  - STAT 값 : 프로세스 상태
    - R = 실행가능
    - T = 추적 가능
    - D = 인터텁트 불가능
    - S = 인터럽트 가능
    - s = 세션리더
    - Z = 좀비
    - I = 아이들 상태의 커널 쓰레드

### top

- 3초 동안 수집한 리눅스 프로세스 정보를 지속적으로 제공하는 도구
- 가장 CPU를 많이 사용하는 프로세스를 화면의 맨 위에 배치

### htop

- top + 시각화
- 마우스도 사용가능
- tree 형태로 확인 가능

### kill

- 프로세스 종료 명령어
- kill [-signal] pid
  - SIGTERM 15 : 실행을 완전하게 종결, 시그널 수신 가능
  - SIGKILL 9 : 차단 불가능, 시그널 수신 불가능(강제 종료)
  - SIGINT 2 : 터미널에서 ctrl + c입력시 전송
- 권장하는 프로세스 종료 방식
  - **kill -15 종료 해보고 , kill - 9를 시도하는 것을 권장**

# proc 파일 시스템의 이해

커널 정보를 어떻게 리눅스들이 가져올 수 있을까요?

## proc 파일 시스템

- 커널이 시스템 상태와 관련한 다양한 정보를 노출 시키는 가상 파일 시스템
  - 프로세스 정보 뿐만 아니라 다른 시스템 정보들까지 광범위하게 제공해 준다.
  - 프로세스상황 감시, CPU 사용율, 인터럽트 , 네트워크 패킷 전송량 등등
  -
- 운영체제의 각종 정보를 커널 모드가 아닌 유저모드에서 쉽게 접근할 수 있도록 제공
  - 일반 프로그래머가 쉽게 접근할 수 있도록 도와준다.
- proc 파일 시스템에서 직접 데이터를 읽기보다는 ps,top,vmstat 등 다양한 명령어를 사용
  - 잘 알려지지 않은 정보가 필요한 경우 proc 정보를 직접 읽어야함

### 프로세스와 관련된 정보

- /proc/PID/cmdline : 프로세스가 실행하고 있는 명령이나 프로그램
- /proc/PID/environ : 프로세스의 환경변수
- /proc/PID/fd : 오픈된 파일 디스크립터
- /proc/PID/exe : 현재 실행중인 파일에 대한 심볼릭 링크
- /proc/PID/stat : 전반적인 프로세스 상태 정보 ← 사람이 읽기에는 ps
- /proc/self 자신의 /proc/PID로 이동

### 프로세스와 관련 없는 시스템 정보

- /proc/cpuinfo : 프로세서 정보(벤더와 스피드, 캐시 크기, 코어
  등)
- /proc/meminfo : 메모리 관리 정보
- /proc/diskstats : 논리 디스크 장치들 정보
- /proc/net : 네트워크 스택과 관련된 주요 정보
- /proc/version : 커널의 버전 정보
- /proc/uptime : 부트 이후 경과된 시간 정보
- /proc/cmdline : 커널에 넘겨지는 부트 옵션
- /proc/kmsg : 커널이 출력하는 메시지

# 주기적 실행 작업 관리

## 활용 예

- 크롤링
- 백업 및 미러링
- 일 단위 메일 전송
- 로그 파일 로테이션

## cron (cron job)

- 정의된 스케줄에 따라 명령을 실행하는 도구
- crontab 관리 (cron table)
  - crontab -e : 편집
  - crontab -l : 리스트 출력
  - crontab -r : 삭제
- root 사용자는 다른 사용자의 crontab 정보 확인 가능
  - crontab -e USER_ID

## crontab 설정 방법

- 분(0-59) 시(0-24) 일(1-31) 월(1-12) 요일(0-6) 명령

예) \* \* \* \* _ command : 매 1분 마다 명령을 실행
예) 0 _ \* \* _ command : 매 1시간 마다 명령을 실행
예) 0 0 _ \* _ command : 매 1일 마다 명령을 실행
예) 0 2 _ \* _ command : 매일 새벽 2시에 명령을 실행
예) 0 2 _ \* 6 command : 매주 토요일 새벽 2시마다 명령을 실행

# (실습) crontab으로 로그 파일 관리 설정

운영 중에 로그 파일이나 임시 파일의 증가로

disk full 관련한 장애가 적지 않개 발생하는데

이를 크론탭으로 관리하는 파일 관리방법에 대해 실습

## 로그 파일 관리 정책

- 매일 로그 파일 관리 프로그램 실행
- 날짜가 지나면 로그 파일을 로테이트
  - 이전 날짜의 로그는 별도 이름으로 저장
  - 예) access.log, access.log.1
- 2주가 지난 로그파일은 삭제
- 오래된 로그 파일은 압축된 형태로 저장
  - 예) access.log, access.log.1, access.log.2.gz

```powershell
$sudo apt install nginx
```

NGINX 패키지 설치 과정에 로그 파일관리 내용이 이미 포함 되어 있음

## logrotate

- 로그 파일 관리를 도와주는 도구
- 지원기능
  - 로그 압축, 제거, 특정 기간 단위로 로그 분리, 메일 전송 등
- 6-3 로그파일 관리에서 자세하게 다룸

## crontab 설정은 어떻게?

- 이미 시스템에 구성이 되어 있음

## 사용자 정의 cron job

- crontab -e 로 작성 하게 되면
- 사용자별로 /var/spool/cron/crontabs 해당 설정들이 저장

## 시스템 정의 cron job

- /etc/crontab 에 등록 되어있음

```powershell
$vim /etc/crontab
$vim /etc/cron.daily/logrotate
/etc/logrotate.conf를 가지고 실행
$vim /etc/logrotate.conf
$cd /etc/logrotate.d
```

- 일 단위 주기적 작업에 logrotate가 등록되어, 지정된 시간에 매일 logrotate가 실행
- logrotate는 /etc/logrotate.d 디렉토리 내에 등록된 작업(nginx)을 진행
- 시스템에 일반적으로 시간/일/주/월 단위의 주기적 작업을 위한 구성이 만들어져 있음
  - cron.hourly, cron.daily, crontab.weekly, crontab.monthly
  - 해당 디렉토리에 실행할 작업을 스크립트 형태로 등록하면 됨

## 별도의 로그 관리 기능 구현이 필요한 경우

- crontab은 신경 쓸 필요 없음
- /etc/logrotate.d에 logrotate 설정 파일만 추가 하면 된다.
